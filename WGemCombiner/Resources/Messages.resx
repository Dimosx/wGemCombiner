<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="HelpCombiner2Message" xml:space="preserve">
    <value>You can cancel the combine by pressing the 'Escape' key (you may have to hold it for a second with lag). Using a delay lower than GC2's frame time will cause input to be ahead of what you see happening, and so canceling may appear to not work. If your cursor has stopped moving, the program has stopped.

If you need to save a specific amount of space on the top, lower the Slot Limit box, though this will require more moves to complete the same combine, sometimes significantly.

Game gem info tooltips have to be hidden during the combine. The combiner will automatically hide them and reshow after the combine (pressing '.' in-game), unless configured differently in the options.</value>
  </data>
  <data name="HelpCombiner2Title" xml:space="preserve">
    <value>Working with the combiner (2)</value>
  </data>
  <data name="HelpCombinerMessage" xml:space="preserve">
    <value>Select the desired kind of recipe ("Mana Spec" for a managem, etc...) and an affordable combine - the first number is the number of basegems used for the combine.
After performing a Spec and an Amp recipe, you don't need to use that anymore, after this first step use only "Combine" recipes on these initially created gems. Again, the first number indicates the amount of basegems needed. You can use that to calculate the manacost.

After choosing the recipe, you switch to the game and perform the following steps:
- Place the base gem(s) in the bottom-right inventory slot(s), following the base gems box instructions.
- Empty the inventory up to at least as many slots as the combine requires.
- Press the 'Combine' button (displays the hotkey to press if in automatic mode or already pressed).
- Hover your cursor over the right-most base gem (slot 1A).
- Press the '{0}' key.

The displayed list of instructions should be pretty self-explanatory. 1A is bottom-right, 1C is bottom-left, 12C is top-left.</value>
    <comment>Standalone versions allow even smaller delays and they buffer mouse moves, but almost nobody will be using them, so not documenting it.</comment>
  </data>
  <data name="HelpCombinerTitle" xml:space="preserve">
    <value>Working with the combiner (1)</value>
  </data>
  <data name="HelpCreditsMessage" xml:space="preserve">
    <value>Contributors (alphabetic order):
- 12345ieee: some spec parsing, GUI tweaks, preset recipes, general project management
- CooLTanG: automate some steps, fix window size/resolution issues, customizable hotkey
- Hellrage: some GUI tweaks, skin, small bug fixes, preset and resource management
- RobinHood70: code cleaning and revamping; partial localization support; improved recipe parsing
- Suuper: original author, initial idea, main program logic


Release version: {0}

To report a problem, see
https://github.com/gemforce-team/wGemCombiner#report-bugs

If you wish to contribute/donate to the project, see
https://github.com/gemforce-team/wGemCombiner#credits
</value>
  </data>
  <data name="HelpCreditsTitle" xml:space="preserve">
    <value>Credits</value>
  </data>
  <data name="HelpFirstTimeMessage" xml:space="preserve">
    <value>This seems to be the first time you opened WGemCombiner, so the Help section was opened automatically.
It is possible to reopen it manually from the program at any time.

It is recommended to read at least the "Working with the Combiner" sections, to have a basic idea of how the program works.

Have fun. </value>
    <comment>This section is shown only at the first open</comment>
  </data>
  <data name="HelpFirstTimeTitle" xml:space="preserve">
    <value>Welcome to WGemCombiner</value>
  </data>
  <data name="HelpGESMessage" xml:space="preserve">
    <value>When using the Gem Enhancement Shrine (GES), the optimal killgem building method is different from the usual.

The best way is to use the GES repeatedly with a Yellow g1 (no need to enhance the Black gem at all) and to hitfarm with a Black-Red g2.

The best specs and amps in this case are different than the normal killgem+amps ones, and are collected in a separate list, called GES Specs/Amps.

Both GES Spec and Amps' Yellow g1 have to be copies of the enhanced Yellow g1, while the Black gem can be a normal Black g1.
GES Killgem specs contain a peculiar Hitfarm gem in place of the Red one, the gem required there is the Black-Red g2 used for hitfarming.

These recipes grant up to x2 the kill power when using GES, compared to using normal killgem recipes.
</value>
  </data>
  <data name="HelpGESTitle" xml:space="preserve">
    <value>GES Killgem recipes</value>
  </data>
  <data name="HelpImportingPresetsMessage" xml:space="preserve">
    <value>To import new recipes, open or create the "recipes.txt" file in the same folder as your executable. Either parenthetical or equation recipes can be used, with equation recipes requiring a blank line between them.
Comments can also be inserted on separate lines beginning with # or //.</value>
  </data>
  <data name="HelpImportingPresetsTitle" xml:space="preserve">
    <value>Adding New Recipes</value>
  </data>
  <data name="HelpInputFormatMessage" xml:space="preserve">
    <value>You can also paste gem combining equations or a parenthesis formula into the text box, then click one of the 'Parse recipe' buttons.

Example of equation format:
0 = o
1 = 0 + 0
2 = 1 + 0
3 = 2 + 0

Example of parenthesis format (same recipe as above):
(2o+o)+o

Equations are faster to process, though this will only be noticeable with large recipes or large numbers of recipes in the recipes.txt file.</value>
  </data>
  <data name="HelpInputFormatTitle" xml:space="preserve">
    <value>Input recipes directly</value>
  </data>
  <data name="HelpPresetsMessage" xml:space="preserve">
    <value>To use one of the built-in recipes, first select a color + combine/spec from the top drop-down list.

After selecting a color + combine/spec, the second drop-down list will display the preset options. The first number is number of base gems; the second number is the growth rate. Those marked with a '*' are 2^n combines, and are rarely the best for growth rate up to that cost. They are mostly included for convenience if you want easily comparable gem costs.

Selecting a preset will display the recipe in the custom parser box. If desired, you can change the recipe and click the 'Parse recipe' button to generate a new set of equations and instructions to be used.

The specs are optimized for a gem and 6/8 amplifiers with the correct proportions (-3/-4 grades, the exact matching numbers can be found on gemforce repo).

The combines are optimized to be used both on a gem and its amps, the high leech combines are provided to grant a smaller extra edge over this.

Recipes come from the *-combine and *-amps series of gemforce 1.8.0:
http://github.com/gemforce-team/gemforce#readme
</value>
  </data>
  <data name="HelpPresetsTitle" xml:space="preserve">
    <value>Presets</value>
  </data>
</root>